// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_
#define FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_

#include "flatbuffers/flatbuffers.h"

#include "Tensor_generated.h"
#include "Type_generated.h"

namespace MNN {

struct BinaryOp;
struct BinaryOpT;

struct PackParam;
struct PackParamT;

struct StridedSliceParam;
struct StridedSliceParamT;

struct SqueezeParam;
struct SqueezeParamT;

struct CastParam;
struct CastParamT;

struct ReductionParam;
struct ReductionParamT;

struct Gather;
struct GatherT;

struct ExpandDims;
struct ExpandDimsT;

struct Selu;
struct SeluT;

struct AsString;
struct AsStringT;

struct ReduceJoin;
struct ReduceJoinT;

struct UnaryOp;
struct UnaryOpT;

struct TopKV2;
struct TopKV2T;

struct CropAndResize;
struct CropAndResizeT;

struct Fill;
struct FillT;

struct GatherV2;
struct GatherV2T;

struct NonMaxSuppressionV2;
struct NonMaxSuppressionV2T;

struct Range;
struct RangeT;

struct Rank;
struct RankT;

struct Size;
struct SizeT;

struct Transpose;
struct TransposeT;

struct SliceTf;
struct SliceTfT;

struct QuantizeMaxMin;
struct QuantizeMaxMinT;

struct Crop;
struct CropT;

struct SpaceBatch;
struct SpaceBatchT;

struct MatMul;
struct MatMulT;

struct MomentsParam;
struct MomentsParamT;

struct RNNParam;
struct RNNParamT;

struct BatchMatMulParam;
struct BatchMatMulParamT;

struct DepthSpaceParam;
struct DepthSpaceParamT;

inline const flatbuffers::TypeTable *BinaryOpTypeTable();

inline const flatbuffers::TypeTable *PackParamTypeTable();

inline const flatbuffers::TypeTable *StridedSliceParamTypeTable();

inline const flatbuffers::TypeTable *SqueezeParamTypeTable();

inline const flatbuffers::TypeTable *CastParamTypeTable();

inline const flatbuffers::TypeTable *ReductionParamTypeTable();

inline const flatbuffers::TypeTable *GatherTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsTypeTable();

inline const flatbuffers::TypeTable *SeluTypeTable();

inline const flatbuffers::TypeTable *AsStringTypeTable();

inline const flatbuffers::TypeTable *ReduceJoinTypeTable();

inline const flatbuffers::TypeTable *UnaryOpTypeTable();

inline const flatbuffers::TypeTable *TopKV2TypeTable();

inline const flatbuffers::TypeTable *CropAndResizeTypeTable();

inline const flatbuffers::TypeTable *FillTypeTable();

inline const flatbuffers::TypeTable *GatherV2TypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionV2TypeTable();

inline const flatbuffers::TypeTable *RangeTypeTable();

inline const flatbuffers::TypeTable *RankTypeTable();

inline const flatbuffers::TypeTable *SizeTypeTable();

inline const flatbuffers::TypeTable *TransposeTypeTable();

inline const flatbuffers::TypeTable *SliceTfTypeTable();

inline const flatbuffers::TypeTable *QuantizeMaxMinTypeTable();

inline const flatbuffers::TypeTable *CropTypeTable();

inline const flatbuffers::TypeTable *SpaceBatchTypeTable();

inline const flatbuffers::TypeTable *MatMulTypeTable();

inline const flatbuffers::TypeTable *MomentsParamTypeTable();

inline const flatbuffers::TypeTable *RNNParamTypeTable();

inline const flatbuffers::TypeTable *BatchMatMulParamTypeTable();

inline const flatbuffers::TypeTable *DepthSpaceParamTypeTable();

enum BinaryOpOperation {
  BinaryOpOperation_ADD = 0,
  BinaryOpOperation_SUB = 1,
  BinaryOpOperation_MUL = 2,
  BinaryOpOperation_DIV = 3,
  BinaryOpOperation_MAX_TEMP = 4,
  BinaryOpOperation_MIN_TEMP = 5,
  BinaryOpOperation_POW = 6,
  BinaryOpOperation_REALDIV = 7,
  BinaryOpOperation_MINIMUM = 8,
  BinaryOpOperation_MAXIMUM = 9,
  BinaryOpOperation_GREATER = 10,
  BinaryOpOperation_GREATER_EQUAL = 11,
  BinaryOpOperation_LESS = 12,
  BinaryOpOperation_FLOORDIV = 13,
  BinaryOpOperation_SquaredDifference = 14,
  BinaryOpOperation_EQUAL = 15,
  BinaryOpOperation_MIN = BinaryOpOperation_ADD,
  BinaryOpOperation_MAX = BinaryOpOperation_EQUAL
};

inline const BinaryOpOperation (&EnumValuesBinaryOpOperation())[16] {
  static const BinaryOpOperation values[] = {
    BinaryOpOperation_ADD,
    BinaryOpOperation_SUB,
    BinaryOpOperation_MUL,
    BinaryOpOperation_DIV,
    BinaryOpOperation_MAX_TEMP,
    BinaryOpOperation_MIN_TEMP,
    BinaryOpOperation_POW,
    BinaryOpOperation_REALDIV,
    BinaryOpOperation_MINIMUM,
    BinaryOpOperation_MAXIMUM,
    BinaryOpOperation_GREATER,
    BinaryOpOperation_GREATER_EQUAL,
    BinaryOpOperation_LESS,
    BinaryOpOperation_FLOORDIV,
    BinaryOpOperation_SquaredDifference,
    BinaryOpOperation_EQUAL
  };
  return values;
}

inline const char * const *EnumNamesBinaryOpOperation() {
  static const char * const names[] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameBinaryOpOperation(BinaryOpOperation e) {
  if (e < BinaryOpOperation_ADD || e > BinaryOpOperation_EQUAL) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesBinaryOpOperation()[index];
}

enum ReductionType {
  ReductionType_SUM = 0,
  ReductionType_ASUM = 1,
  ReductionType_SUMSQ = 2,
  ReductionType_MEAN = 3,
  ReductionType_MAXIMUM = 4,
  ReductionType_MINIMUM = 5,
  ReductionType_PROD = 6,
  ReductionType_MIN = ReductionType_SUM,
  ReductionType_MAX = ReductionType_PROD
};

inline const ReductionType (&EnumValuesReductionType())[7] {
  static const ReductionType values[] = {
    ReductionType_SUM,
    ReductionType_ASUM,
    ReductionType_SUMSQ,
    ReductionType_MEAN,
    ReductionType_MAXIMUM,
    ReductionType_MINIMUM,
    ReductionType_PROD
  };
  return values;
}

inline const char * const *EnumNamesReductionType() {
  static const char * const names[] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD",
    nullptr
  };
  return names;
}

inline const char *EnumNameReductionType(ReductionType e) {
  if (e < ReductionType_SUM || e > ReductionType_PROD) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesReductionType()[index];
}

enum UnaryOpOperation {
  UnaryOpOperation_ABS = 0,
  UnaryOpOperation_NEG = 1,
  UnaryOpOperation_FLOOR = 2,
  UnaryOpOperation_CEIL = 3,
  UnaryOpOperation_SQUARE = 4,
  UnaryOpOperation_SQRT = 5,
  UnaryOpOperation_RSQRT = 6,
  UnaryOpOperation_EXP = 7,
  UnaryOpOperation_LOG = 8,
  UnaryOpOperation_SIN = 9,
  UnaryOpOperation_COS = 10,
  UnaryOpOperation_TAN = 11,
  UnaryOpOperation_ASIN = 12,
  UnaryOpOperation_ACOS = 13,
  UnaryOpOperation_ATAN = 14,
  UnaryOpOperation_RECIPROCAL = 15,
  UnaryOpOperation_LOG1P = 16,
  UnaryOpOperation_MIN = UnaryOpOperation_ABS,
  UnaryOpOperation_MAX = UnaryOpOperation_LOG1P
};

inline const UnaryOpOperation (&EnumValuesUnaryOpOperation())[17] {
  static const UnaryOpOperation values[] = {
    UnaryOpOperation_ABS,
    UnaryOpOperation_NEG,
    UnaryOpOperation_FLOOR,
    UnaryOpOperation_CEIL,
    UnaryOpOperation_SQUARE,
    UnaryOpOperation_SQRT,
    UnaryOpOperation_RSQRT,
    UnaryOpOperation_EXP,
    UnaryOpOperation_LOG,
    UnaryOpOperation_SIN,
    UnaryOpOperation_COS,
    UnaryOpOperation_TAN,
    UnaryOpOperation_ASIN,
    UnaryOpOperation_ACOS,
    UnaryOpOperation_ATAN,
    UnaryOpOperation_RECIPROCAL,
    UnaryOpOperation_LOG1P
  };
  return values;
}

inline const char * const *EnumNamesUnaryOpOperation() {
  static const char * const names[] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnaryOpOperation(UnaryOpOperation e) {
  if (e < UnaryOpOperation_ABS || e > UnaryOpOperation_LOG1P) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesUnaryOpOperation()[index];
}

enum CropAndResizeMethod {
  CropAndResizeMethod_BILINEAR = 0,
  CropAndResizeMethod_NEAREST = 1,
  CropAndResizeMethod_MIN = CropAndResizeMethod_BILINEAR,
  CropAndResizeMethod_MAX = CropAndResizeMethod_NEAREST
};

inline const CropAndResizeMethod (&EnumValuesCropAndResizeMethod())[2] {
  static const CropAndResizeMethod values[] = {
    CropAndResizeMethod_BILINEAR,
    CropAndResizeMethod_NEAREST
  };
  return values;
}

inline const char * const *EnumNamesCropAndResizeMethod() {
  static const char * const names[] = {
    "BILINEAR",
    "NEAREST",
    nullptr
  };
  return names;
}

inline const char *EnumNameCropAndResizeMethod(CropAndResizeMethod e) {
  if (e < CropAndResizeMethod_BILINEAR || e > CropAndResizeMethod_NEAREST) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesCropAndResizeMethod()[index];
}

struct BinaryOpT : public flatbuffers::NativeTable {
  typedef BinaryOp TableType;
  int32_t opType;
  DataType T;
  BinaryOpT()
      : opType(0),
        T(DataType_DT_FLOAT) {
  }
};

struct BinaryOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryOpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryOpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTYPE = 4,
    VT_T = 6
  };
  int32_t opType() const {
    return GetField<int32_t>(VT_OPTYPE, 0);
  }
  bool mutate_opType(int32_t _opType) {
    return SetField<int32_t>(VT_OPTYPE, _opType, 0);
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 1));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OPTYPE) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           verifier.EndTable();
  }
  BinaryOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryOpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opType(int32_t opType) {
    fbb_.AddElement<int32_t>(BinaryOp::VT_OPTYPE, opType, 0);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(BinaryOp::VT_T, static_cast<int32_t>(T), 1);
  }
  explicit BinaryOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryOpBuilder &operator=(const BinaryOpBuilder &);
  flatbuffers::Offset<BinaryOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryOp> CreateBinaryOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t opType = 0,
    DataType T = DataType_DT_FLOAT) {
  BinaryOpBuilder builder_(_fbb);
  builder_.add_T(T);
  builder_.add_opType(opType);
  return builder_.Finish();
}

flatbuffers::Offset<BinaryOp> CreateBinaryOp(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackParamT : public flatbuffers::NativeTable {
  typedef PackParam TableType;
  DataType dataType;
  int32_t axis;
  PackParamT()
      : dataType(DataType_DT_INVALID),
        axis(0) {
  }
};

struct PackParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PackParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PackParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_AXIS = 6
  };
  DataType dataType() const {
    return static_cast<DataType>(GetField<int32_t>(VT_DATATYPE, 0));
  }
  bool mutate_dataType(DataType _dataType) {
    return SetField<int32_t>(VT_DATATYPE, static_cast<int32_t>(_dataType), 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  PackParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PackParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(DataType dataType) {
    fbb_.AddElement<int32_t>(PackParam::VT_DATATYPE, static_cast<int32_t>(dataType), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackParam::VT_AXIS, axis, 0);
  }
  explicit PackParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackParamBuilder &operator=(const PackParamBuilder &);
  flatbuffers::Offset<PackParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackParam> CreatePackParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType dataType = DataType_DT_INVALID,
    int32_t axis = 0) {
  PackParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

flatbuffers::Offset<PackParam> CreatePackParam(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceParamT : public flatbuffers::NativeTable {
  typedef StridedSliceParam TableType;
  DataType Index;
  DataType T;
  int32_t beginMask;
  int32_t endMask;
  int32_t ellipsisMask;
  int32_t newAxisMask;
  int32_t shrinkAxisMask;
  StridedSliceParamT()
      : Index(DataType_DT_INVALID),
        T(DataType_DT_INVALID),
        beginMask(0),
        endMask(0),
        ellipsisMask(0),
        newAxisMask(0),
        shrinkAxisMask(0) {
  }
};

struct StridedSliceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StridedSliceParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_T = 6,
    VT_BEGINMASK = 8,
    VT_ENDMASK = 10,
    VT_ELLIPSISMASK = 12,
    VT_NEWAXISMASK = 14,
    VT_SHRINKAXISMASK = 16
  };
  DataType Index() const {
    return static_cast<DataType>(GetField<int32_t>(VT_INDEX, 0));
  }
  bool mutate_Index(DataType _Index) {
    return SetField<int32_t>(VT_INDEX, static_cast<int32_t>(_Index), 0);
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  int32_t beginMask() const {
    return GetField<int32_t>(VT_BEGINMASK, 0);
  }
  bool mutate_beginMask(int32_t _beginMask) {
    return SetField<int32_t>(VT_BEGINMASK, _beginMask, 0);
  }
  int32_t endMask() const {
    return GetField<int32_t>(VT_ENDMASK, 0);
  }
  bool mutate_endMask(int32_t _endMask) {
    return SetField<int32_t>(VT_ENDMASK, _endMask, 0);
  }
  int32_t ellipsisMask() const {
    return GetField<int32_t>(VT_ELLIPSISMASK, 0);
  }
  bool mutate_ellipsisMask(int32_t _ellipsisMask) {
    return SetField<int32_t>(VT_ELLIPSISMASK, _ellipsisMask, 0);
  }
  int32_t newAxisMask() const {
    return GetField<int32_t>(VT_NEWAXISMASK, 0);
  }
  bool mutate_newAxisMask(int32_t _newAxisMask) {
    return SetField<int32_t>(VT_NEWAXISMASK, _newAxisMask, 0);
  }
  int32_t shrinkAxisMask() const {
    return GetField<int32_t>(VT_SHRINKAXISMASK, 0);
  }
  bool mutate_shrinkAxisMask(int32_t _shrinkAxisMask) {
    return SetField<int32_t>(VT_SHRINKAXISMASK, _shrinkAxisMask, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<int32_t>(verifier, VT_BEGINMASK) &&
           VerifyField<int32_t>(verifier, VT_ENDMASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSISMASK) &&
           VerifyField<int32_t>(verifier, VT_NEWAXISMASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINKAXISMASK) &&
           verifier.EndTable();
  }
  StridedSliceParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(DataType Index) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_INDEX, static_cast<int32_t>(Index), 0);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_beginMask(int32_t beginMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_BEGINMASK, beginMask, 0);
  }
  void add_endMask(int32_t endMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_ENDMASK, endMask, 0);
  }
  void add_ellipsisMask(int32_t ellipsisMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_ELLIPSISMASK, ellipsisMask, 0);
  }
  void add_newAxisMask(int32_t newAxisMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_NEWAXISMASK, newAxisMask, 0);
  }
  void add_shrinkAxisMask(int32_t shrinkAxisMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_SHRINKAXISMASK, shrinkAxisMask, 0);
  }
  explicit StridedSliceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceParamBuilder &operator=(const StridedSliceParamBuilder &);
  flatbuffers::Offset<StridedSliceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Index = DataType_DT_INVALID,
    DataType T = DataType_DT_INVALID,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0) {
  StridedSliceParamBuilder builder_(_fbb);
  builder_.add_shrinkAxisMask(shrinkAxisMask);
  builder_.add_newAxisMask(newAxisMask);
  builder_.add_ellipsisMask(ellipsisMask);
  builder_.add_endMask(endMask);
  builder_.add_beginMask(beginMask);
  builder_.add_T(T);
  builder_.add_Index(Index);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeParamT : public flatbuffers::NativeTable {
  typedef SqueezeParam TableType;
  std::vector<int32_t> squeezeDims;
  SqueezeParamT() {
  }
};

struct SqueezeParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqueezeParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZEDIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeezeDims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZEDIMS);
  }
  flatbuffers::Vector<int32_t> *mutable_squeezeDims() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SQUEEZEDIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZEDIMS) &&
           verifier.VerifyVector(squeezeDims()) &&
           verifier.EndTable();
  }
  SqueezeParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqueezeParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeezeDims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeezeDims) {
    fbb_.AddOffset(SqueezeParam::VT_SQUEEZEDIMS, squeezeDims);
  }
  explicit SqueezeParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeParamBuilder &operator=(const SqueezeParamBuilder &);
  flatbuffers::Offset<SqueezeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeezeDims = 0) {
  SqueezeParamBuilder builder_(_fbb);
  builder_.add_squeezeDims(squeezeDims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeezeDims = nullptr) {
  auto squeezeDims__ = squeezeDims ? _fbb.CreateVector<int32_t>(*squeezeDims) : 0;
  return MNN::CreateSqueezeParam(
      _fbb,
      squeezeDims__);
}

flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastParamT : public flatbuffers::NativeTable {
  typedef CastParam TableType;
  DataType srcT;
  DataType dstT;
  CastParamT()
      : srcT(DataType_DT_INVALID),
        dstT(DataType_DT_INVALID) {
  }
};

struct CastParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CastParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  DataType srcT() const {
    return static_cast<DataType>(GetField<int32_t>(VT_SRCT, 0));
  }
  bool mutate_srcT(DataType _srcT) {
    return SetField<int32_t>(VT_SRCT, static_cast<int32_t>(_srcT), 0);
  }
  DataType dstT() const {
    return static_cast<DataType>(GetField<int32_t>(VT_DSTT, 0));
  }
  bool mutate_dstT(DataType _dstT) {
    return SetField<int32_t>(VT_DSTT, static_cast<int32_t>(_dstT), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
  CastParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CastParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(DataType srcT) {
    fbb_.AddElement<int32_t>(CastParam::VT_SRCT, static_cast<int32_t>(srcT), 0);
  }
  void add_dstT(DataType dstT) {
    fbb_.AddElement<int32_t>(CastParam::VT_DSTT, static_cast<int32_t>(dstT), 0);
  }
  explicit CastParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastParamBuilder &operator=(const CastParamBuilder &);
  flatbuffers::Offset<CastParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastParam> CreateCastParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType srcT = DataType_DT_INVALID,
    DataType dstT = DataType_DT_INVALID) {
  CastParamBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

flatbuffers::Offset<CastParam> CreateCastParam(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReductionParamT : public flatbuffers::NativeTable {
  typedef ReductionParam TableType;
  ReductionType operation;
  std::vector<int32_t> dim;
  float coeff;
  bool keepDims;
  DataType dType;
  ReductionParamT()
      : operation(ReductionType_SUM),
        coeff(0.0f),
        keepDims(false),
        dType(DataType_DT_FLOAT) {
  }
};

struct ReductionParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReductionParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReductionParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION = 4,
    VT_DIM = 6,
    VT_COEFF = 8,
    VT_KEEPDIMS = 10,
    VT_DTYPE = 12
  };
  ReductionType operation() const {
    return static_cast<ReductionType>(GetField<int8_t>(VT_OPERATION, 0));
  }
  bool mutate_operation(ReductionType _operation) {
    return SetField<int8_t>(VT_OPERATION, static_cast<int8_t>(_operation), 0);
  }
  const flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  flatbuffers::Vector<int32_t> *mutable_dim() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool mutate_coeff(float _coeff) {
    return SetField<float>(VT_COEFF, _coeff, 0.0f);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool mutate_keepDims(bool _keepDims) {
    return SetField<uint8_t>(VT_KEEPDIMS, static_cast<uint8_t>(_keepDims), 0);
  }
  DataType dType() const {
    return static_cast<DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  bool mutate_dType(DataType _dType) {
    return SetField<int32_t>(VT_DTYPE, static_cast<int32_t>(_dType), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPERATION) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_DTYPE) &&
           verifier.EndTable();
  }
  ReductionParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReductionParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReductionParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReductionParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation(ReductionType operation) {
    fbb_.AddElement<int8_t>(ReductionParam::VT_OPERATION, static_cast<int8_t>(operation), 0);
  }
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(ReductionParam::VT_DIM, dim);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(ReductionParam::VT_COEFF, coeff, 0.0f);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ReductionParam::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_dType(DataType dType) {
    fbb_.AddElement<int32_t>(ReductionParam::VT_DTYPE, static_cast<int32_t>(dType), 1);
  }
  explicit ReductionParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReductionParamBuilder &operator=(const ReductionParamBuilder &);
  flatbuffers::Offset<ReductionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReductionParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReductionParam> CreateReductionParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    ReductionType operation = ReductionType_SUM,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim = 0,
    float coeff = 0.0f,
    bool keepDims = false,
    DataType dType = DataType_DT_FLOAT) {
  ReductionParamBuilder builder_(_fbb);
  builder_.add_dType(dType);
  builder_.add_coeff(coeff);
  builder_.add_dim(dim);
  builder_.add_keepDims(keepDims);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReductionParam> CreateReductionParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ReductionType operation = ReductionType_SUM,
    const std::vector<int32_t> *dim = nullptr,
    float coeff = 0.0f,
    bool keepDims = false,
    DataType dType = DataType_DT_FLOAT) {
  auto dim__ = dim ? _fbb.CreateVector<int32_t>(*dim) : 0;
  return MNN::CreateReductionParam(
      _fbb,
      operation,
      dim__,
      coeff,
      keepDims,
      dType);
}

flatbuffers::Offset<ReductionParam> CreateReductionParam(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherT : public flatbuffers::NativeTable {
  typedef Gather TableType;
  DataType Tindices;
  DataType Tparams;
  bool validateIndices;
  int32_t axis;
  GatherT()
      : Tindices(DataType_DT_INVALID),
        Tparams(DataType_DT_INVALID),
        validateIndices(false),
        axis(0) {
  }
};

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TINDICES = 4,
    VT_TPARAMS = 6,
    VT_VALIDATEINDICES = 8,
    VT_AXIS = 10
  };
  DataType Tindices() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TINDICES, 0));
  }
  bool mutate_Tindices(DataType _Tindices) {
    return SetField<int32_t>(VT_TINDICES, static_cast<int32_t>(_Tindices), 0);
  }
  DataType Tparams() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TPARAMS, 0));
  }
  bool mutate_Tparams(DataType _Tparams) {
    return SetField<int32_t>(VT_TPARAMS, static_cast<int32_t>(_Tparams), 0);
  }
  bool validateIndices() const {
    return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
  }
  bool mutate_validateIndices(bool _validateIndices) {
    return SetField<uint8_t>(VT_VALIDATEINDICES, static_cast<uint8_t>(_validateIndices), 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TINDICES) &&
           VerifyField<int32_t>(verifier, VT_TPARAMS) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  GatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tindices(DataType Tindices) {
    fbb_.AddElement<int32_t>(Gather::VT_TINDICES, static_cast<int32_t>(Tindices), 0);
  }
  void add_Tparams(DataType Tparams) {
    fbb_.AddElement<int32_t>(Gather::VT_TPARAMS, static_cast<int32_t>(Tparams), 0);
  }
  void add_validateIndices(bool validateIndices) {
    fbb_.AddElement<uint8_t>(Gather::VT_VALIDATEINDICES, static_cast<uint8_t>(validateIndices), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Gather::VT_AXIS, axis, 0);
  }
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherBuilder &operator=(const GatherBuilder &);
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Tindices = DataType_DT_INVALID,
    DataType Tparams = DataType_DT_INVALID,
    bool validateIndices = false,
    int32_t axis = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_Tparams(Tparams);
  builder_.add_Tindices(Tindices);
  builder_.add_validateIndices(validateIndices);
  return builder_.Finish();
}

flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsT : public flatbuffers::NativeTable {
  typedef ExpandDims TableType;
  DataType T;
  DataType Tdim;
  int32_t axis;
  ExpandDimsT()
      : T(DataType_DT_INVALID),
        Tdim(DataType_DT_INVALID),
        axis(0) {
  }
};

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpandDimsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_TDIM = 6,
    VT_AXIS = 8
  };
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  DataType Tdim() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TDIM, 0));
  }
  bool mutate_Tdim(DataType _Tdim) {
    return SetField<int32_t>(VT_TDIM, static_cast<int32_t>(_Tdim), 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<int32_t>(verifier, VT_TDIM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  ExpandDimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_Tdim(DataType Tdim) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_TDIM, static_cast<int32_t>(Tdim), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_AXIS, axis, 0);
  }
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsBuilder &operator=(const ExpandDimsBuilder &);
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    DataType Tdim = DataType_DT_INVALID,
    int32_t axis = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_Tdim(Tdim);
  builder_.add_T(T);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SeluT : public flatbuffers::NativeTable {
  typedef Selu TableType;
  float scale;
  float alpha;
  SeluT()
      : scale(0.0f),
        alpha(0.0f) {
  }
};

struct Selu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SeluT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SeluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ALPHA = 6
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  SeluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SeluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Selu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SeluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(Selu::VT_SCALE, scale, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Selu::VT_ALPHA, alpha, 0.0f);
  }
  explicit SeluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SeluBuilder &operator=(const SeluBuilder &);
  flatbuffers::Offset<Selu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Selu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Selu> CreateSelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float alpha = 0.0f) {
  SeluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<Selu> CreateSelu(flatbuffers::FlatBufferBuilder &_fbb, const SeluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AsStringT : public flatbuffers::NativeTable {
  typedef AsString TableType;
  DataType T;
  int32_t precision;
  bool scientific;
  bool shortest;
  int32_t width;
  std::string fillString;
  AsStringT()
      : T(DataType_DT_INVALID),
        precision(0),
        scientific(false),
        shortest(false),
        width(0) {
  }
};

struct AsString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AsStringT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AsStringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_PRECISION = 6,
    VT_SCIENTIFIC = 8,
    VT_SHORTEST = 10,
    VT_WIDTH = 12,
    VT_FILLSTRING = 14
  };
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  bool mutate_precision(int32_t _precision) {
    return SetField<int32_t>(VT_PRECISION, _precision, 0);
  }
  bool scientific() const {
    return GetField<uint8_t>(VT_SCIENTIFIC, 0) != 0;
  }
  bool mutate_scientific(bool _scientific) {
    return SetField<uint8_t>(VT_SCIENTIFIC, static_cast<uint8_t>(_scientific), 0);
  }
  bool shortest() const {
    return GetField<uint8_t>(VT_SHORTEST, 0) != 0;
  }
  bool mutate_shortest(bool _shortest) {
    return SetField<uint8_t>(VT_SHORTEST, static_cast<uint8_t>(_shortest), 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  bool mutate_width(int32_t _width) {
    return SetField<int32_t>(VT_WIDTH, _width, 0);
  }
  const flatbuffers::String *fillString() const {
    return GetPointer<const flatbuffers::String *>(VT_FILLSTRING);
  }
  flatbuffers::String *mutable_fillString() {
    return GetPointer<flatbuffers::String *>(VT_FILLSTRING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<int32_t>(verifier, VT_PRECISION) &&
           VerifyField<uint8_t>(verifier, VT_SCIENTIFIC) &&
           VerifyField<uint8_t>(verifier, VT_SHORTEST) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_FILLSTRING) &&
           verifier.VerifyString(fillString()) &&
           verifier.EndTable();
  }
  AsStringT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AsStringT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AsString> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AsStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(AsString::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(AsString::VT_PRECISION, precision, 0);
  }
  void add_scientific(bool scientific) {
    fbb_.AddElement<uint8_t>(AsString::VT_SCIENTIFIC, static_cast<uint8_t>(scientific), 0);
  }
  void add_shortest(bool shortest) {
    fbb_.AddElement<uint8_t>(AsString::VT_SHORTEST, static_cast<uint8_t>(shortest), 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(AsString::VT_WIDTH, width, 0);
  }
  void add_fillString(flatbuffers::Offset<flatbuffers::String> fillString) {
    fbb_.AddOffset(AsString::VT_FILLSTRING, fillString);
  }
  explicit AsStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AsStringBuilder &operator=(const AsStringBuilder &);
  flatbuffers::Offset<AsString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AsString>(end);
    return o;
  }
};

inline flatbuffers::Offset<AsString> CreateAsString(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    int32_t precision = 0,
    bool scientific = false,
    bool shortest = false,
    int32_t width = 0,
    flatbuffers::Offset<flatbuffers::String> fillString = 0) {
  AsStringBuilder builder_(_fbb);
  builder_.add_fillString(fillString);
  builder_.add_width(width);
  builder_.add_precision(precision);
  builder_.add_T(T);
  builder_.add_shortest(shortest);
  builder_.add_scientific(scientific);
  return builder_.Finish();
}

inline flatbuffers::Offset<AsString> CreateAsStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    int32_t precision = 0,
    bool scientific = false,
    bool shortest = false,
    int32_t width = 0,
    const char *fillString = nullptr) {
  auto fillString__ = fillString ? _fbb.CreateString(fillString) : 0;
  return MNN::CreateAsString(
      _fbb,
      T,
      precision,
      scientific,
      shortest,
      width,
      fillString__);
}

flatbuffers::Offset<AsString> CreateAsString(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceJoinT : public flatbuffers::NativeTable {
  typedef ReduceJoin TableType;
  bool keepDims;
  std::string separator;
  ReduceJoinT()
      : keepDims(false) {
  }
};

struct ReduceJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceJoinT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceJoinTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEPDIMS = 4,
    VT_SEPARATOR = 6
  };
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool mutate_keepDims(bool _keepDims) {
    return SetField<uint8_t>(VT_KEEPDIMS, static_cast<uint8_t>(_keepDims), 0);
  }
  const flatbuffers::String *separator() const {
    return GetPointer<const flatbuffers::String *>(VT_SEPARATOR);
  }
  flatbuffers::String *mutable_separator() {
    return GetPointer<flatbuffers::String *>(VT_SEPARATOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyOffset(verifier, VT_SEPARATOR) &&
           verifier.VerifyString(separator()) &&
           verifier.EndTable();
  }
  ReduceJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceJoinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ReduceJoin::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_separator(flatbuffers::Offset<flatbuffers::String> separator) {
    fbb_.AddOffset(ReduceJoin::VT_SEPARATOR, separator);
  }
  explicit ReduceJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceJoinBuilder &operator=(const ReduceJoinBuilder &);
  flatbuffers::Offset<ReduceJoin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceJoin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceJoin> CreateReduceJoin(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keepDims = false,
    flatbuffers::Offset<flatbuffers::String> separator = 0) {
  ReduceJoinBuilder builder_(_fbb);
  builder_.add_separator(separator);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReduceJoin> CreateReduceJoinDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keepDims = false,
    const char *separator = nullptr) {
  auto separator__ = separator ? _fbb.CreateString(separator) : 0;
  return MNN::CreateReduceJoin(
      _fbb,
      keepDims,
      separator__);
}

flatbuffers::Offset<ReduceJoin> CreateReduceJoin(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnaryOpT : public flatbuffers::NativeTable {
  typedef UnaryOp TableType;
  UnaryOpOperation opType;
  DataType T;
  UnaryOpT()
      : opType(UnaryOpOperation_ABS),
        T(DataType_DT_INVALID) {
  }
};

struct UnaryOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnaryOpT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnaryOpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTYPE = 4,
    VT_T = 6
  };
  UnaryOpOperation opType() const {
    return static_cast<UnaryOpOperation>(GetField<int32_t>(VT_OPTYPE, 0));
  }
  bool mutate_opType(UnaryOpOperation _opType) {
    return SetField<int32_t>(VT_OPTYPE, static_cast<int32_t>(_opType), 0);
  }
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OPTYPE) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           verifier.EndTable();
  }
  UnaryOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnaryOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnaryOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnaryOpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opType(UnaryOpOperation opType) {
    fbb_.AddElement<int32_t>(UnaryOp::VT_OPTYPE, static_cast<int32_t>(opType), 0);
  }
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(UnaryOp::VT_T, static_cast<int32_t>(T), 0);
  }
  explicit UnaryOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnaryOpBuilder &operator=(const UnaryOpBuilder &);
  flatbuffers::Offset<UnaryOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnaryOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnaryOp> CreateUnaryOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    UnaryOpOperation opType = UnaryOpOperation_ABS,
    DataType T = DataType_DT_INVALID) {
  UnaryOpBuilder builder_(_fbb);
  builder_.add_T(T);
  builder_.add_opType(opType);
  return builder_.Finish();
}

flatbuffers::Offset<UnaryOp> CreateUnaryOp(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKV2T : public flatbuffers::NativeTable {
  typedef TopKV2 TableType;
  DataType T;
  bool sorted;
  TopKV2T()
      : T(DataType_DT_FLOAT),
        sorted(false) {
  }
};

struct TopKV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKV2T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopKV2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_SORTED = 6
  };
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 1));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 1);
  }
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 0) != 0;
  }
  bool mutate_sorted(bool _sorted) {
    return SetField<uint8_t>(VT_SORTED, static_cast<uint8_t>(_sorted), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           verifier.EndTable();
  }
  TopKV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(TopKV2::VT_T, static_cast<int32_t>(T), 1);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopKV2::VT_SORTED, static_cast<uint8_t>(sorted), 0);
  }
  explicit TopKV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2Builder &operator=(const TopKV2Builder &);
  flatbuffers::Offset<TopKV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2> CreateTopKV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_FLOAT,
    bool sorted = false) {
  TopKV2Builder builder_(_fbb);
  builder_.add_T(T);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

flatbuffers::Offset<TopKV2> CreateTopKV2(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropAndResizeT : public flatbuffers::NativeTable {
  typedef CropAndResize TableType;
  float extrapolationValue;
  CropAndResizeMethod method;
  CropAndResizeT()
      : extrapolationValue(0.0f),
        method(CropAndResizeMethod_BILINEAR) {
  }
};

struct CropAndResize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropAndResizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropAndResizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTRAPOLATIONVALUE = 4,
    VT_METHOD = 6
  };
  float extrapolationValue() const {
    return GetField<float>(VT_EXTRAPOLATIONVALUE, 0.0f);
  }
  bool mutate_extrapolationValue(float _extrapolationValue) {
    return SetField<float>(VT_EXTRAPOLATIONVALUE, _extrapolationValue, 0.0f);
  }
  CropAndResizeMethod method() const {
    return static_cast<CropAndResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool mutate_method(CropAndResizeMethod _method) {
    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATIONVALUE) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           verifier.EndTable();
  }
  CropAndResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CropAndResize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropAndResizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extrapolationValue(float extrapolationValue) {
    fbb_.AddElement<float>(CropAndResize::VT_EXTRAPOLATIONVALUE, extrapolationValue, 0.0f);
  }
  void add_method(CropAndResizeMethod method) {
    fbb_.AddElement<int8_t>(CropAndResize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  explicit CropAndResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CropAndResizeBuilder &operator=(const CropAndResizeBuilder &);
  flatbuffers::Offset<CropAndResize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CropAndResize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float extrapolationValue = 0.0f,
    CropAndResizeMethod method = CropAndResizeMethod_BILINEAR) {
  CropAndResizeBuilder builder_(_fbb);
  builder_.add_extrapolationValue(extrapolationValue);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillT : public flatbuffers::NativeTable {
  typedef Fill TableType;
  FillT() {
  }
};

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FillTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fill> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillBuilder &operator=(const FillBuilder &);
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherV2T : public flatbuffers::NativeTable {
  typedef GatherV2 TableType;
  DataType Taxis;
  DataType Tindices;
  DataType Tparams;
  GatherV2T()
      : Taxis(DataType_DT_INVALID),
        Tindices(DataType_DT_INVALID),
        Tparams(DataType_DT_INVALID) {
  }
};

struct GatherV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherV2T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherV2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAXIS = 4,
    VT_TINDICES = 6,
    VT_TPARAMS = 8
  };
  DataType Taxis() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TAXIS, 0));
  }
  bool mutate_Taxis(DataType _Taxis) {
    return SetField<int32_t>(VT_TAXIS, static_cast<int32_t>(_Taxis), 0);
  }
  DataType Tindices() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TINDICES, 0));
  }
  bool mutate_Tindices(DataType _Tindices) {
    return SetField<int32_t>(VT_TINDICES, static_cast<int32_t>(_Tindices), 0);
  }
  DataType Tparams() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TPARAMS, 0));
  }
  bool mutate_Tparams(DataType _Tparams) {
    return SetField<int32_t>(VT_TPARAMS, static_cast<int32_t>(_Tparams), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TAXIS) &&
           VerifyField<int32_t>(verifier, VT_TINDICES) &&
           VerifyField<int32_t>(verifier, VT_TPARAMS) &&
           verifier.EndTable();
  }
  GatherV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Taxis(DataType Taxis) {
    fbb_.AddElement<int32_t>(GatherV2::VT_TAXIS, static_cast<int32_t>(Taxis), 0);
  }
  void add_Tindices(DataType Tindices) {
    fbb_.AddElement<int32_t>(GatherV2::VT_TINDICES, static_cast<int32_t>(Tindices), 0);
  }
  void add_Tparams(DataType Tparams) {
    fbb_.AddElement<int32_t>(GatherV2::VT_TPARAMS, static_cast<int32_t>(Tparams), 0);
  }
  explicit GatherV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherV2Builder &operator=(const GatherV2Builder &);
  flatbuffers::Offset<GatherV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherV2> CreateGatherV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Taxis = DataType_DT_INVALID,
    DataType Tindices = DataType_DT_INVALID,
    DataType Tparams = DataType_DT_INVALID) {
  GatherV2Builder builder_(_fbb);
  builder_.add_Tparams(Tparams);
  builder_.add_Tindices(Tindices);
  builder_.add_Taxis(Taxis);
  return builder_.Finish();
}

flatbuffers::Offset<GatherV2> CreateGatherV2(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionV2T : public flatbuffers::NativeTable {
  typedef NonMaxSuppressionV2 TableType;
  NonMaxSuppressionV2T() {
  }
};

struct NonMaxSuppressionV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionV2T NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonMaxSuppressionV2TypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonMaxSuppressionV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppressionV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV2Builder &operator=(const NonMaxSuppressionV2Builder &);
  flatbuffers::Offset<NonMaxSuppressionV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV2Builder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeT : public flatbuffers::NativeTable {
  typedef Range TableType;
  DataType Tidx;
  RangeT()
      : Tidx(DataType_DT_INVALID) {
  }
};

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RangeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIDX = 4
  };
  DataType Tidx() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TIDX, 0));
  }
  bool mutate_Tidx(DataType _Tidx) {
    return SetField<int32_t>(VT_TIDX, static_cast<int32_t>(_Tidx), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIDX) &&
           verifier.EndTable();
  }
  RangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Range> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tidx(DataType Tidx) {
    fbb_.AddElement<int32_t>(Range::VT_TIDX, static_cast<int32_t>(Tidx), 0);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeBuilder &operator=(const RangeBuilder &);
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Tidx = DataType_DT_INVALID) {
  RangeBuilder builder_(_fbb);
  builder_.add_Tidx(Tidx);
  return builder_.Finish();
}

flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankT : public flatbuffers::NativeTable {
  typedef Rank TableType;
  RankT() {
  }
};

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RankTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rank> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankBuilder &operator=(const RankBuilder &);
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SizeT : public flatbuffers::NativeTable {
  typedef Size TableType;
  DataType outputDataType;
  SizeT()
      : outputDataType(DataType_DT_INVALID) {
  }
};

struct Size FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SizeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTDATATYPE = 4
  };
  DataType outputDataType() const {
    return static_cast<DataType>(GetField<int32_t>(VT_OUTPUTDATATYPE, 0));
  }
  bool mutate_outputDataType(DataType _outputDataType) {
    return SetField<int32_t>(VT_OUTPUTDATATYPE, static_cast<int32_t>(_outputDataType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTDATATYPE) &&
           verifier.EndTable();
  }
  SizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Size> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputDataType(DataType outputDataType) {
    fbb_.AddElement<int32_t>(Size::VT_OUTPUTDATATYPE, static_cast<int32_t>(outputDataType), 0);
  }
  explicit SizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SizeBuilder &operator=(const SizeBuilder &);
  flatbuffers::Offset<Size> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Size>(end);
    return o;
  }
};

inline flatbuffers::Offset<Size> CreateSize(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType outputDataType = DataType_DT_INVALID) {
  SizeBuilder builder_(_fbb);
  builder_.add_outputDataType(outputDataType);
  return builder_.Finish();
}

flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeT : public flatbuffers::NativeTable {
  typedef Transpose TableType;
  DataType Tperm;
  TransposeT()
      : Tperm(DataType_DT_INVALID) {
  }
};

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransposeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TPERM = 4
  };
  DataType Tperm() const {
    return static_cast<DataType>(GetField<int32_t>(VT_TPERM, 0));
  }
  bool mutate_Tperm(DataType _Tperm) {
    return SetField<int32_t>(VT_TPERM, static_cast<int32_t>(_Tperm), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TPERM) &&
           verifier.EndTable();
  }
  TransposeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transpose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tperm(DataType Tperm) {
    fbb_.AddElement<int32_t>(Transpose::VT_TPERM, static_cast<int32_t>(Tperm), 0);
  }
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeBuilder &operator=(const TransposeBuilder &);
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType Tperm = DataType_DT_INVALID) {
  TransposeBuilder builder_(_fbb);
  builder_.add_Tperm(Tperm);
  return builder_.Finish();
}

flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceTfT : public flatbuffers::NativeTable {
  typedef SliceTf TableType;
  DataType T;
  SliceTfT()
      : T(DataType_DT_INVALID) {
  }
};

struct SliceTf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceTfT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceTfTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           verifier.EndTable();
  }
  SliceTfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceTfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceTf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceTfBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(SliceTf::VT_T, static_cast<int32_t>(T), 0);
  }
  explicit SliceTfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceTfBuilder &operator=(const SliceTfBuilder &);
  flatbuffers::Offset<SliceTf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceTf>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceTf> CreateSliceTf(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID) {
  SliceTfBuilder builder_(_fbb);
  builder_.add_T(T);
  return builder_.Finish();
}

flatbuffers::Offset<SliceTf> CreateSliceTf(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantizeMaxMinT : public flatbuffers::NativeTable {
  typedef QuantizeMaxMin TableType;
  DataType T;
  QuantizeMaxMinT()
      : T(DataType_DT_INVALID) {
  }
};

struct QuantizeMaxMin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizeMaxMinT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantizeMaxMinTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           verifier.EndTable();
  }
  QuantizeMaxMinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeMaxMinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizeMaxMin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeMaxMinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(QuantizeMaxMin::VT_T, static_cast<int32_t>(T), 0);
  }
  explicit QuantizeMaxMinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeMaxMinBuilder &operator=(const QuantizeMaxMinBuilder &);
  flatbuffers::Offset<QuantizeMaxMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeMaxMin>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID) {
  QuantizeMaxMinBuilder builder_(_fbb);
  builder_.add_T(T);
  return builder_.Finish();
}

flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropT : public flatbuffers::NativeTable {
  typedef Crop TableType;
  int32_t axis;
  std::vector<int32_t> offset;
  CropT()
      : axis(2) {
  }
};

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSET = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 2);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 2);
  }
  const flatbuffers::Vector<int32_t> *offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OFFSET);
  }
  flatbuffers::Vector<int32_t> *mutable_offset() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
  CropT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Crop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Crop::VT_AXIS, axis, 2);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> offset) {
    fbb_.AddOffset(Crop::VT_OFFSET, offset);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CropBuilder &operator=(const CropBuilder &);
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 2,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> offset = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Crop> CreateCropDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 2,
    const std::vector<int32_t> *offset = nullptr) {
  auto offset__ = offset ? _fbb.CreateVector<int32_t>(*offset) : 0;
  return MNN::CreateCrop(
      _fbb,
      axis,
      offset__);
}

flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceBatchT : public flatbuffers::NativeTable {
  typedef SpaceBatch TableType;
  std::unique_ptr<BlobT> blockShape;
  std::unique_ptr<BlobT> padding;
  SpaceBatchT() {
  }
};

struct SpaceBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceBatchT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceBatchTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDING = 6
  };
  const Blob *blockShape() const {
    return GetPointer<const Blob *>(VT_BLOCKSHAPE);
  }
  Blob *mutable_blockShape() {
    return GetPointer<Blob *>(VT_BLOCKSHAPE);
  }
  const Blob *padding() const {
    return GetPointer<const Blob *>(VT_PADDING);
  }
  Blob *mutable_padding() {
    return GetPointer<Blob *>(VT_PADDING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyTable(blockShape()) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyTable(padding()) &&
           verifier.EndTable();
  }
  SpaceBatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceBatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceBatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<Blob> blockShape) {
    fbb_.AddOffset(SpaceBatch::VT_BLOCKSHAPE, blockShape);
  }
  void add_padding(flatbuffers::Offset<Blob> padding) {
    fbb_.AddOffset(SpaceBatch::VT_PADDING, padding);
  }
  explicit SpaceBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceBatchBuilder &operator=(const SpaceBatchBuilder &);
  flatbuffers::Offset<SpaceBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Blob> blockShape = 0,
    flatbuffers::Offset<Blob> padding = 0) {
  SpaceBatchBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatMulT : public flatbuffers::NativeTable {
  typedef MatMul TableType;
  DataType T;
  bool transposeA;
  bool transposeB;
  std::vector<float> weight;
  std::vector<float> bias;
  MatMulT()
      : T(DataType_DT_INVALID),
        transposeA(false),
        transposeB(false) {
  }
};

struct MatMul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatMulT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatMulTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_TRANSPOSEA = 6,
    VT_TRANSPOSEB = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12
  };
  DataType T() const {
    return static_cast<DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool mutate_T(DataType _T) {
    return SetField<int32_t>(VT_T, static_cast<int32_t>(_T), 0);
  }
  bool transposeA() const {
    return GetField<uint8_t>(VT_TRANSPOSEA, 0) != 0;
  }
  bool mutate_transposeA(bool _transposeA) {
    return SetField<uint8_t>(VT_TRANSPOSEA, static_cast<uint8_t>(_transposeA), 0);
  }
  bool transposeB() const {
    return GetField<uint8_t>(VT_TRANSPOSEB, 0) != 0;
  }
  bool mutate_transposeB(bool _transposeB) {
    return SetField<uint8_t>(VT_TRANSPOSEB, static_cast<uint8_t>(_transposeB), 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  flatbuffers::Vector<float> *mutable_weight() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  flatbuffers::Vector<float> *mutable_bias() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEA) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEB) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           verifier.EndTable();
  }
  MatMulT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatMulT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatMul> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatMulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_T(DataType T) {
    fbb_.AddElement<int32_t>(MatMul::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_transposeA(bool transposeA) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEA, static_cast<uint8_t>(transposeA), 0);
  }
  void add_transposeB(bool transposeB) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEB, static_cast<uint8_t>(transposeB), 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(MatMul::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(MatMul::VT_BIAS, bias);
  }
  explicit MatMulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatMulBuilder &operator=(const MatMulBuilder &);
  flatbuffers::Offset<MatMul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMul>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMul> CreateMatMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    bool transposeA = false,
    bool transposeB = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0) {
  MatMulBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_T(T);
  builder_.add_transposeB(transposeB);
  builder_.add_transposeA(transposeA);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatMul> CreateMatMulDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType T = DataType_DT_INVALID,
    bool transposeA = false,
    bool transposeB = false,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return MNN::CreateMatMul(
      _fbb,
      T,
      transposeA,
      transposeB,
      weight__,
      bias__);
}

flatbuffers::Offset<MatMul> CreateMatMul(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MomentsParamT : public flatbuffers::NativeTable {
  typedef MomentsParam TableType;
  std::vector<int32_t> dim;
  bool keepDims;
  DataType dType;
  MomentsParamT()
      : keepDims(true),
        dType(DataType_DT_FLOAT) {
  }
};

struct MomentsParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MomentsParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MomentsParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIMS = 6,
    VT_DTYPE = 8
  };
  const flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  flatbuffers::Vector<int32_t> *mutable_dim() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 1) != 0;
  }
  bool mutate_keepDims(bool _keepDims) {
    return SetField<uint8_t>(VT_KEEPDIMS, static_cast<uint8_t>(_keepDims), 1);
  }
  DataType dType() const {
    return static_cast<DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  bool mutate_dType(DataType _dType) {
    return SetField<int32_t>(VT_DTYPE, static_cast<int32_t>(_dType), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_DTYPE) &&
           verifier.EndTable();
  }
  MomentsParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MomentsParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MomentsParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MomentsParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(MomentsParam::VT_DIM, dim);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(MomentsParam::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 1);
  }
  void add_dType(DataType dType) {
    fbb_.AddElement<int32_t>(MomentsParam::VT_DTYPE, static_cast<int32_t>(dType), 1);
  }
  explicit MomentsParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MomentsParamBuilder &operator=(const MomentsParamBuilder &);
  flatbuffers::Offset<MomentsParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MomentsParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<MomentsParam> CreateMomentsParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim = 0,
    bool keepDims = true,
    DataType dType = DataType_DT_FLOAT) {
  MomentsParamBuilder builder_(_fbb);
  builder_.add_dType(dType);
  builder_.add_dim(dim);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline flatbuffers::Offset<MomentsParam> CreateMomentsParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dim = nullptr,
    bool keepDims = true,
    DataType dType = DataType_DT_FLOAT) {
  auto dim__ = dim ? _fbb.CreateVector<int32_t>(*dim) : 0;
  return MNN::CreateMomentsParam(
      _fbb,
      dim__,
      keepDims,
      dType);
}

flatbuffers::Offset<MomentsParam> CreateMomentsParam(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RNNParamT : public flatbuffers::NativeTable {
  typedef RNNParam TableType;
  int32_t numUnits;
  bool isBidirectionalRNN;
  bool keepAllOutputs;
  std::unique_ptr<BlobT> fwGateWeight;
  std::unique_ptr<BlobT> fwGateBias;
  std::unique_ptr<BlobT> fwCandidateWeight;
  std::unique_ptr<BlobT> fwCandidateBias;
  std::unique_ptr<BlobT> bwGateWeight;
  std::unique_ptr<BlobT> bwGateBias;
  std::unique_ptr<BlobT> bwCandidateWeight;
  std::unique_ptr<BlobT> bwCandidateBias;
  RNNParamT()
      : numUnits(0),
        isBidirectionalRNN(false),
        keepAllOutputs(false) {
  }
};

struct RNNParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RNNParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RNNParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMUNITS = 4,
    VT_ISBIDIRECTIONALRNN = 6,
    VT_KEEPALLOUTPUTS = 8,
    VT_FWGATEWEIGHT = 10,
    VT_FWGATEBIAS = 12,
    VT_FWCANDIDATEWEIGHT = 14,
    VT_FWCANDIDATEBIAS = 16,
    VT_BWGATEWEIGHT = 18,
    VT_BWGATEBIAS = 20,
    VT_BWCANDIDATEWEIGHT = 22,
    VT_BWCANDIDATEBIAS = 24
  };
  int32_t numUnits() const {
    return GetField<int32_t>(VT_NUMUNITS, 0);
  }
  bool mutate_numUnits(int32_t _numUnits) {
    return SetField<int32_t>(VT_NUMUNITS, _numUnits, 0);
  }
  bool isBidirectionalRNN() const {
    return GetField<uint8_t>(VT_ISBIDIRECTIONALRNN, 0) != 0;
  }
  bool mutate_isBidirectionalRNN(bool _isBidirectionalRNN) {
    return SetField<uint8_t>(VT_ISBIDIRECTIONALRNN, static_cast<uint8_t>(_isBidirectionalRNN), 0);
  }
  bool keepAllOutputs() const {
    return GetField<uint8_t>(VT_KEEPALLOUTPUTS, 0) != 0;
  }
  bool mutate_keepAllOutputs(bool _keepAllOutputs) {
    return SetField<uint8_t>(VT_KEEPALLOUTPUTS, static_cast<uint8_t>(_keepAllOutputs), 0);
  }
  const Blob *fwGateWeight() const {
    return GetPointer<const Blob *>(VT_FWGATEWEIGHT);
  }
  Blob *mutable_fwGateWeight() {
    return GetPointer<Blob *>(VT_FWGATEWEIGHT);
  }
  const Blob *fwGateBias() const {
    return GetPointer<const Blob *>(VT_FWGATEBIAS);
  }
  Blob *mutable_fwGateBias() {
    return GetPointer<Blob *>(VT_FWGATEBIAS);
  }
  const Blob *fwCandidateWeight() const {
    return GetPointer<const Blob *>(VT_FWCANDIDATEWEIGHT);
  }
  Blob *mutable_fwCandidateWeight() {
    return GetPointer<Blob *>(VT_FWCANDIDATEWEIGHT);
  }
  const Blob *fwCandidateBias() const {
    return GetPointer<const Blob *>(VT_FWCANDIDATEBIAS);
  }
  Blob *mutable_fwCandidateBias() {
    return GetPointer<Blob *>(VT_FWCANDIDATEBIAS);
  }
  const Blob *bwGateWeight() const {
    return GetPointer<const Blob *>(VT_BWGATEWEIGHT);
  }
  Blob *mutable_bwGateWeight() {
    return GetPointer<Blob *>(VT_BWGATEWEIGHT);
  }
  const Blob *bwGateBias() const {
    return GetPointer<const Blob *>(VT_BWGATEBIAS);
  }
  Blob *mutable_bwGateBias() {
    return GetPointer<Blob *>(VT_BWGATEBIAS);
  }
  const Blob *bwCandidateWeight() const {
    return GetPointer<const Blob *>(VT_BWCANDIDATEWEIGHT);
  }
  Blob *mutable_bwCandidateWeight() {
    return GetPointer<Blob *>(VT_BWCANDIDATEWEIGHT);
  }
  const Blob *bwCandidateBias() const {
    return GetPointer<const Blob *>(VT_BWCANDIDATEBIAS);
  }
  Blob *mutable_bwCandidateBias() {
    return GetPointer<Blob *>(VT_BWCANDIDATEBIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMUNITS) &&
           VerifyField<uint8_t>(verifier, VT_ISBIDIRECTIONALRNN) &&
           VerifyField<uint8_t>(verifier, VT_KEEPALLOUTPUTS) &&
           VerifyOffset(verifier, VT_FWGATEWEIGHT) &&
           verifier.VerifyTable(fwGateWeight()) &&
           VerifyOffset(verifier, VT_FWGATEBIAS) &&
           verifier.VerifyTable(fwGateBias()) &&
           VerifyOffset(verifier, VT_FWCANDIDATEWEIGHT) &&
           verifier.VerifyTable(fwCandidateWeight()) &&
           VerifyOffset(verifier, VT_FWCANDIDATEBIAS) &&
           verifier.VerifyTable(fwCandidateBias()) &&
           VerifyOffset(verifier, VT_BWGATEWEIGHT) &&
           verifier.VerifyTable(bwGateWeight()) &&
           VerifyOffset(verifier, VT_BWGATEBIAS) &&
           verifier.VerifyTable(bwGateBias()) &&
           VerifyOffset(verifier, VT_BWCANDIDATEWEIGHT) &&
           verifier.VerifyTable(bwCandidateWeight()) &&
           VerifyOffset(verifier, VT_BWCANDIDATEBIAS) &&
           verifier.VerifyTable(bwCandidateBias()) &&
           verifier.EndTable();
  }
  RNNParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RNNParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RNNParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RNNParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numUnits(int32_t numUnits) {
    fbb_.AddElement<int32_t>(RNNParam::VT_NUMUNITS, numUnits, 0);
  }
  void add_isBidirectionalRNN(bool isBidirectionalRNN) {
    fbb_.AddElement<uint8_t>(RNNParam::VT_ISBIDIRECTIONALRNN, static_cast<uint8_t>(isBidirectionalRNN), 0);
  }
  void add_keepAllOutputs(bool keepAllOutputs) {
    fbb_.AddElement<uint8_t>(RNNParam::VT_KEEPALLOUTPUTS, static_cast<uint8_t>(keepAllOutputs), 0);
  }
  void add_fwGateWeight(flatbuffers::Offset<Blob> fwGateWeight) {
    fbb_.AddOffset(RNNParam::VT_FWGATEWEIGHT, fwGateWeight);
  }
  void add_fwGateBias(flatbuffers::Offset<Blob> fwGateBias) {
    fbb_.AddOffset(RNNParam::VT_FWGATEBIAS, fwGateBias);
  }
  void add_fwCandidateWeight(flatbuffers::Offset<Blob> fwCandidateWeight) {
    fbb_.AddOffset(RNNParam::VT_FWCANDIDATEWEIGHT, fwCandidateWeight);
  }
  void add_fwCandidateBias(flatbuffers::Offset<Blob> fwCandidateBias) {
    fbb_.AddOffset(RNNParam::VT_FWCANDIDATEBIAS, fwCandidateBias);
  }
  void add_bwGateWeight(flatbuffers::Offset<Blob> bwGateWeight) {
    fbb_.AddOffset(RNNParam::VT_BWGATEWEIGHT, bwGateWeight);
  }
  void add_bwGateBias(flatbuffers::Offset<Blob> bwGateBias) {
    fbb_.AddOffset(RNNParam::VT_BWGATEBIAS, bwGateBias);
  }
  void add_bwCandidateWeight(flatbuffers::Offset<Blob> bwCandidateWeight) {
    fbb_.AddOffset(RNNParam::VT_BWCANDIDATEWEIGHT, bwCandidateWeight);
  }
  void add_bwCandidateBias(flatbuffers::Offset<Blob> bwCandidateBias) {
    fbb_.AddOffset(RNNParam::VT_BWCANDIDATEBIAS, bwCandidateBias);
  }
  explicit RNNParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNParamBuilder &operator=(const RNNParamBuilder &);
  flatbuffers::Offset<RNNParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNParam> CreateRNNParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numUnits = 0,
    bool isBidirectionalRNN = false,
    bool keepAllOutputs = false,
    flatbuffers::Offset<Blob> fwGateWeight = 0,
    flatbuffers::Offset<Blob> fwGateBias = 0,
    flatbuffers::Offset<Blob> fwCandidateWeight = 0,
    flatbuffers::Offset<Blob> fwCandidateBias = 0,
    flatbuffers::Offset<Blob> bwGateWeight = 0,
    flatbuffers::Offset<Blob> bwGateBias = 0,
    flatbuffers::Offset<Blob> bwCandidateWeight = 0,
    flatbuffers::Offset<Blob> bwCandidateBias = 0) {
  RNNParamBuilder builder_(_fbb);
  builder_.add_bwCandidateBias(bwCandidateBias);
  builder_.add_bwCandidateWeight(bwCandidateWeight);
  builder_.add_bwGateBias(bwGateBias);
  builder_.add_bwGateWeight(bwGateWeight);
  builder_.add_fwCandidateBias(fwCandidateBias);
  builder_.add_fwCandidateWeight(fwCandidateWeight);
  builder_.add_fwGateBias(fwGateBias);
  builder_.add_fwGateWeight(fwGateWeight);
  builder_.add_numUnits(numUnits);
  builder_.add_keepAllOutputs(keepAllOutputs);
  builder_.add_isBidirectionalRNN(isBidirectionalRNN);
  return builder_.Finish();
}

flatbuffers::Offset<RNNParam> CreateRNNParam(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchMatMulParamT : public flatbuffers::NativeTable {
  typedef BatchMatMulParam TableType;
  bool adjX;
  bool adjY;
  BatchMatMulParamT()
      : adjX(false),
        adjY(false) {
  }
};

struct BatchMatMulParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchMatMulParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchMatMulParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADJX = 4,
    VT_ADJY = 6
  };
  bool adjX() const {
    return GetField<uint8_t>(VT_ADJX, 0) != 0;
  }
  bool mutate_adjX(bool _adjX) {
    return SetField<uint8_t>(VT_ADJX, static_cast<uint8_t>(_adjX), 0);
  }
  bool adjY() const {
    return GetField<uint8_t>(VT_ADJY, 0) != 0;
  }
  bool mutate_adjY(bool _adjY) {
    return SetField<uint8_t>(VT_ADJY, static_cast<uint8_t>(_adjY), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADJX) &&
           VerifyField<uint8_t>(verifier, VT_ADJY) &&
           verifier.EndTable();
  }
  BatchMatMulParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchMatMulParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchMatMulParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchMatMulParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_adjX(bool adjX) {
    fbb_.AddElement<uint8_t>(BatchMatMulParam::VT_ADJX, static_cast<uint8_t>(adjX), 0);
  }
  void add_adjY(bool adjY) {
    fbb_.AddElement<uint8_t>(BatchMatMulParam::VT_ADJY, static_cast<uint8_t>(adjY), 0);
  }
  explicit BatchMatMulParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchMatMulParamBuilder &operator=(const BatchMatMulParamBuilder &);
  flatbuffers::Offset<BatchMatMulParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool adjX = false,
    bool adjY = false) {
  BatchMatMulParamBuilder builder_(_fbb);
  builder_.add_adjY(adjY);
  builder_.add_adjX(adjX);
  return builder_.Finish();
}

flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthSpaceParamT : public flatbuffers::NativeTable {
  typedef DepthSpaceParam TableType;
  int32_t blockSize;
  DepthSpaceParamT()
      : blockSize(0) {
  }
};

struct DepthSpaceParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthSpaceParamT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthSpaceParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  bool mutate_blockSize(int32_t _blockSize) {
    return SetField<int32_t>(VT_BLOCKSIZE, _blockSize, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           verifier.EndTable();
  }
  DepthSpaceParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthSpaceParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthSpaceParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthSpaceParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(DepthSpaceParam::VT_BLOCKSIZE, blockSize, 0);
  }
  explicit DepthSpaceParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthSpaceParamBuilder &operator=(const DepthSpaceParamBuilder &);
  flatbuffers::Offset<DepthSpaceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthSpaceParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0) {
  DepthSpaceParamBuilder builder_(_fbb);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BinaryOpT *BinaryOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BinaryOpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BinaryOp::UnPackTo(BinaryOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opType(); _o->opType = _e; };
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<BinaryOp> BinaryOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryOp> CreateBinaryOp(flatbuffers::FlatBufferBuilder &_fbb, const BinaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opType = _o->opType;
  auto _T = _o->T;
  return MNN::CreateBinaryOp(
      _fbb,
      _opType,
      _T);
}

inline PackParamT *PackParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PackParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PackParam::UnPackTo(PackParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataType(); _o->dataType = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<PackParam> PackParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PackParam> CreatePackParam(flatbuffers::FlatBufferBuilder &_fbb, const PackParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataType = _o->dataType;
  auto _axis = _o->axis;
  return MNN::CreatePackParam(
      _fbb,
      _dataType,
      _axis);
}

inline StridedSliceParamT *StridedSliceParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StridedSliceParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StridedSliceParam::UnPackTo(StridedSliceParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Index(); _o->Index = _e; };
  { auto _e = T(); _o->T = _e; };
  { auto _e = beginMask(); _o->beginMask = _e; };
  { auto _e = endMask(); _o->endMask = _e; };
  { auto _e = ellipsisMask(); _o->ellipsisMask = _e; };
  { auto _e = newAxisMask(); _o->newAxisMask = _e; };
  { auto _e = shrinkAxisMask(); _o->shrinkAxisMask = _e; };
}

inline flatbuffers::Offset<StridedSliceParam> StridedSliceParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Index = _o->Index;
  auto _T = _o->T;
  auto _beginMask = _o->beginMask;
  auto _endMask = _o->endMask;
  auto _ellipsisMask = _o->ellipsisMask;
  auto _newAxisMask = _o->newAxisMask;
  auto _shrinkAxisMask = _o->shrinkAxisMask;
  return MNN::CreateStridedSliceParam(
      _fbb,
      _Index,
      _T,
      _beginMask,
      _endMask,
      _ellipsisMask,
      _newAxisMask,
      _shrinkAxisMask);
}

inline SqueezeParamT *SqueezeParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SqueezeParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SqueezeParam::UnPackTo(SqueezeParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = squeezeDims(); if (_e) { _o->squeezeDims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeezeDims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<SqueezeParam> SqueezeParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueezeParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _squeezeDims = _o->squeezeDims.size() ? _fbb.CreateVector(_o->squeezeDims) : 0;
  return MNN::CreateSqueezeParam(
      _fbb,
      _squeezeDims);
}

inline CastParamT *CastParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CastParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CastParam::UnPackTo(CastParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = srcT(); _o->srcT = _e; };
  { auto _e = dstT(); _o->dstT = _e; };
}

inline flatbuffers::Offset<CastParam> CastParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCastParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CastParam> CreateCastParam(flatbuffers::FlatBufferBuilder &_fbb, const CastParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _srcT = _o->srcT;
  auto _dstT = _o->dstT;
  return MNN::CreateCastParam(
      _fbb,
      _srcT,
      _dstT);
}

inline ReductionParamT *ReductionParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReductionParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReductionParam::UnPackTo(ReductionParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = operation(); _o->operation = _e; };
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim[_i] = _e->Get(_i); } } };
  { auto _e = coeff(); _o->coeff = _e; };
  { auto _e = keepDims(); _o->keepDims = _e; };
  { auto _e = dType(); _o->dType = _e; };
}

inline flatbuffers::Offset<ReductionParam> ReductionParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReductionParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReductionParam> CreateReductionParam(flatbuffers::FlatBufferBuilder &_fbb, const ReductionParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReductionParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _operation = _o->operation;
  auto _dim = _o->dim.size() ? _fbb.CreateVector(_o->dim) : 0;
  auto _coeff = _o->coeff;
  auto _keepDims = _o->keepDims;
  auto _dType = _o->dType;
  return MNN::CreateReductionParam(
      _fbb,
      _operation,
      _dim,
      _coeff,
      _keepDims,
      _dType);
}

inline GatherT *Gather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Gather::UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tindices(); _o->Tindices = _e; };
  { auto _e = Tparams(); _o->Tparams = _e; };
  { auto _e = validateIndices(); _o->validateIndices = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<Gather> Gather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGather(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tindices = _o->Tindices;
  auto _Tparams = _o->Tparams;
  auto _validateIndices = _o->validateIndices;
  auto _axis = _o->axis;
  return MNN::CreateGather(
      _fbb,
      _Tindices,
      _Tparams,
      _validateIndices,
      _axis);
}

inline ExpandDimsT *ExpandDims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExpandDimsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ExpandDims::UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = Tdim(); _o->Tdim = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<ExpandDims> ExpandDims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDims(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _Tdim = _o->Tdim;
  auto _axis = _o->axis;
  return MNN::CreateExpandDims(
      _fbb,
      _T,
      _Tdim,
      _axis);
}

inline SeluT *Selu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SeluT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Selu::UnPackTo(SeluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; };
  { auto _e = alpha(); _o->alpha = _e; };
}

inline flatbuffers::Offset<Selu> Selu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SeluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Selu> CreateSelu(flatbuffers::FlatBufferBuilder &_fbb, const SeluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SeluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _alpha = _o->alpha;
  return MNN::CreateSelu(
      _fbb,
      _scale,
      _alpha);
}

inline AsStringT *AsString::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AsStringT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AsString::UnPackTo(AsStringT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = precision(); _o->precision = _e; };
  { auto _e = scientific(); _o->scientific = _e; };
  { auto _e = shortest(); _o->shortest = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = fillString(); if (_e) _o->fillString = _e->str(); };
}

inline flatbuffers::Offset<AsString> AsString::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAsString(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AsString> CreateAsString(flatbuffers::FlatBufferBuilder &_fbb, const AsStringT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AsStringT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _precision = _o->precision;
  auto _scientific = _o->scientific;
  auto _shortest = _o->shortest;
  auto _width = _o->width;
  auto _fillString = _o->fillString.empty() ? 0 : _fbb.CreateString(_o->fillString);
  return MNN::CreateAsString(
      _fbb,
      _T,
      _precision,
      _scientific,
      _shortest,
      _width,
      _fillString);
}

inline ReduceJoinT *ReduceJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReduceJoinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReduceJoin::UnPackTo(ReduceJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keepDims(); _o->keepDims = _e; };
  { auto _e = separator(); if (_e) _o->separator = _e->str(); };
}

inline flatbuffers::Offset<ReduceJoin> ReduceJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceJoin> CreateReduceJoin(flatbuffers::FlatBufferBuilder &_fbb, const ReduceJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceJoinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keepDims = _o->keepDims;
  auto _separator = _o->separator.empty() ? 0 : _fbb.CreateString(_o->separator);
  return MNN::CreateReduceJoin(
      _fbb,
      _keepDims,
      _separator);
}

inline UnaryOpT *UnaryOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnaryOpT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnaryOp::UnPackTo(UnaryOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opType(); _o->opType = _e; };
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<UnaryOp> UnaryOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnaryOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnaryOp> CreateUnaryOp(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnaryOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opType = _o->opType;
  auto _T = _o->T;
  return MNN::CreateUnaryOp(
      _fbb,
      _opType,
      _T);
}

inline TopKV2T *TopKV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TopKV2T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TopKV2::UnPackTo(TopKV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = sorted(); _o->sorted = _e; };
}

inline flatbuffers::Offset<TopKV2> TopKV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKV2> CreateTopKV2(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _sorted = _o->sorted;
  return MNN::CreateTopKV2(
      _fbb,
      _T,
      _sorted);
}

inline CropAndResizeT *CropAndResize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CropAndResizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CropAndResize::UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = extrapolationValue(); _o->extrapolationValue = _e; };
  { auto _e = method(); _o->method = _e; };
}

inline flatbuffers::Offset<CropAndResize> CropAndResize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCropAndResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropAndResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _extrapolationValue = _o->extrapolationValue;
  auto _method = _o->method;
  return MNN::CreateCropAndResize(
      _fbb,
      _extrapolationValue,
      _method);
}

inline FillT *Fill::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FillT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Fill::UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Fill> Fill::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFill(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MNN::CreateFill(
      _fbb);
}

inline GatherV2T *GatherV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherV2T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherV2::UnPackTo(GatherV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Taxis(); _o->Taxis = _e; };
  { auto _e = Tindices(); _o->Tindices = _e; };
  { auto _e = Tparams(); _o->Tparams = _e; };
}

inline flatbuffers::Offset<GatherV2> GatherV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherV2> CreateGatherV2(flatbuffers::FlatBufferBuilder &_fbb, const GatherV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Taxis = _o->Taxis;
  auto _Tindices = _o->Tindices;
  auto _Tparams = _o->Tparams;
  return MNN::CreateGatherV2(
      _fbb,
      _Taxis,
      _Tindices,
      _Tparams);
}

inline NonMaxSuppressionV2T *NonMaxSuppressionV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NonMaxSuppressionV2T();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NonMaxSuppressionV2::UnPackTo(NonMaxSuppressionV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonMaxSuppressionV2> NonMaxSuppressionV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppressionV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MNN::CreateNonMaxSuppressionV2(
      _fbb);
}

inline RangeT *Range::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RangeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Range::UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tidx(); _o->Tidx = _e; };
}

inline flatbuffers::Offset<Range> Range::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tidx = _o->Tidx;
  return MNN::CreateRange(
      _fbb,
      _Tidx);
}

inline RankT *Rank::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RankT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Rank::UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rank> Rank::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRank(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MNN::CreateRank(
      _fbb);
}

inline SizeT *Size::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SizeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Size::UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputDataType(); _o->outputDataType = _e; };
}

inline flatbuffers::Offset<Size> Size::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputDataType = _o->outputDataType;
  return MNN::CreateSize(
      _fbb,
      _outputDataType);
}

inline TransposeT *Transpose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransposeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transpose::UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tperm(); _o->Tperm = _e; };
}

inline flatbuffers::Offset<Transpose> Transpose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTranspose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tperm = _o->Tperm;
  return MNN::CreateTranspose(
      _fbb,
      _Tperm);
}

inline SliceTfT *SliceTf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SliceTfT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SliceTf::UnPackTo(SliceTfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<SliceTf> SliceTf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceTf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceTf> CreateSliceTf(flatbuffers::FlatBufferBuilder &_fbb, const SliceTfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceTfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  return MNN::CreateSliceTf(
      _fbb,
      _T);
}

inline QuantizeMaxMinT *QuantizeMaxMin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizeMaxMinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizeMaxMin::UnPackTo(QuantizeMaxMinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
}

inline flatbuffers::Offset<QuantizeMaxMin> QuantizeMaxMin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizeMaxMin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeMaxMinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizeMaxMinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  return MNN::CreateQuantizeMaxMin(
      _fbb,
      _T);
}

inline CropT *Crop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CropT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Crop::UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = offset(); if (_e) { _o->offset.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offset[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Crop> Crop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _offset = _o->offset.size() ? _fbb.CreateVector(_o->offset) : 0;
  return MNN::CreateCrop(
      _fbb,
      _axis,
      _offset);
}

inline SpaceBatchT *SpaceBatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpaceBatchT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpaceBatch::UnPackTo(SpaceBatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockShape(); if (_e) _o->blockShape = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = padding(); if (_e) _o->padding = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SpaceBatch> SpaceBatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceBatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceBatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockShape = _o->blockShape ? CreateBlob(_fbb, _o->blockShape.get(), _rehasher) : 0;
  auto _padding = _o->padding ? CreateBlob(_fbb, _o->padding.get(), _rehasher) : 0;
  return MNN::CreateSpaceBatch(
      _fbb,
      _blockShape,
      _padding);
}

inline MatMulT *MatMul::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MatMulT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MatMul::UnPackTo(MatMulT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = T(); _o->T = _e; };
  { auto _e = transposeA(); _o->transposeA = _e; };
  { auto _e = transposeB(); _o->transposeB = _e; };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<MatMul> MatMul::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatMul(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatMul> CreateMatMul(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatMulT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _T = _o->T;
  auto _transposeA = _o->transposeA;
  auto _transposeB = _o->transposeB;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  return MNN::CreateMatMul(
      _fbb,
      _T,
      _transposeA,
      _transposeB,
      _weight,
      _bias);
}

inline MomentsParamT *MomentsParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MomentsParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MomentsParam::UnPackTo(MomentsParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim[_i] = _e->Get(_i); } } };
  { auto _e = keepDims(); _o->keepDims = _e; };
  { auto _e = dType(); _o->dType = _e; };
}

inline flatbuffers::Offset<MomentsParam> MomentsParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMomentsParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MomentsParam> CreateMomentsParam(flatbuffers::FlatBufferBuilder &_fbb, const MomentsParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MomentsParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim = _o->dim.size() ? _fbb.CreateVector(_o->dim) : 0;
  auto _keepDims = _o->keepDims;
  auto _dType = _o->dType;
  return MNN::CreateMomentsParam(
      _fbb,
      _dim,
      _keepDims,
      _dType);
}

inline RNNParamT *RNNParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RNNParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RNNParam::UnPackTo(RNNParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numUnits(); _o->numUnits = _e; };
  { auto _e = isBidirectionalRNN(); _o->isBidirectionalRNN = _e; };
  { auto _e = keepAllOutputs(); _o->keepAllOutputs = _e; };
  { auto _e = fwGateWeight(); if (_e) _o->fwGateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwGateBias(); if (_e) _o->fwGateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwCandidateWeight(); if (_e) _o->fwCandidateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = fwCandidateBias(); if (_e) _o->fwCandidateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwGateWeight(); if (_e) _o->bwGateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwGateBias(); if (_e) _o->bwGateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwCandidateWeight(); if (_e) _o->bwCandidateWeight = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
  { auto _e = bwCandidateBias(); if (_e) _o->bwCandidateBias = std::unique_ptr<BlobT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<RNNParam> RNNParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRNNParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RNNParam> CreateRNNParam(flatbuffers::FlatBufferBuilder &_fbb, const RNNParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RNNParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numUnits = _o->numUnits;
  auto _isBidirectionalRNN = _o->isBidirectionalRNN;
  auto _keepAllOutputs = _o->keepAllOutputs;
  auto _fwGateWeight = _o->fwGateWeight ? CreateBlob(_fbb, _o->fwGateWeight.get(), _rehasher) : 0;
  auto _fwGateBias = _o->fwGateBias ? CreateBlob(_fbb, _o->fwGateBias.get(), _rehasher) : 0;
  auto _fwCandidateWeight = _o->fwCandidateWeight ? CreateBlob(_fbb, _o->fwCandidateWeight.get(), _rehasher) : 0;
  auto _fwCandidateBias = _o->fwCandidateBias ? CreateBlob(_fbb, _o->fwCandidateBias.get(), _rehasher) : 0;
  auto _bwGateWeight = _o->bwGateWeight ? CreateBlob(_fbb, _o->bwGateWeight.get(), _rehasher) : 0;
  auto _bwGateBias = _o->bwGateBias ? CreateBlob(_fbb, _o->bwGateBias.get(), _rehasher) : 0;
  auto _bwCandidateWeight = _o->bwCandidateWeight ? CreateBlob(_fbb, _o->bwCandidateWeight.get(), _rehasher) : 0;
  auto _bwCandidateBias = _o->bwCandidateBias ? CreateBlob(_fbb, _o->bwCandidateBias.get(), _rehasher) : 0;
  return MNN::CreateRNNParam(
      _fbb,
      _numUnits,
      _isBidirectionalRNN,
      _keepAllOutputs,
      _fwGateWeight,
      _fwGateBias,
      _fwCandidateWeight,
      _fwCandidateBias,
      _bwGateWeight,
      _bwGateBias,
      _bwCandidateWeight,
      _bwCandidateBias);
}

inline BatchMatMulParamT *BatchMatMulParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchMatMulParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BatchMatMulParam::UnPackTo(BatchMatMulParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = adjX(); _o->adjX = _e; };
  { auto _e = adjY(); _o->adjY = _e; };
}

inline flatbuffers::Offset<BatchMatMulParam> BatchMatMulParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchMatMulParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _adjX = _o->adjX;
  auto _adjY = _o->adjY;
  return MNN::CreateBatchMatMulParam(
      _fbb,
      _adjX,
      _adjY);
}

inline DepthSpaceParamT *DepthSpaceParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DepthSpaceParamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DepthSpaceParam::UnPackTo(DepthSpaceParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockSize(); _o->blockSize = _e; };
}

inline flatbuffers::Offset<DepthSpaceParam> DepthSpaceParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthSpaceParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(flatbuffers::FlatBufferBuilder &_fbb, const DepthSpaceParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthSpaceParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockSize = _o->blockSize;
  return MNN::CreateDepthSpaceParam(
      _fbb,
      _blockSize);
}

inline const flatbuffers::TypeTable *BinaryOpOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BinaryOpOperationTypeTable
  };
  static const char * const names[] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 16, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReductionTypeTypeTable
  };
  static const char * const names[] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnaryOpOperationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UnaryOpOperationTypeTable
  };
  static const char * const names[] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 17, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropAndResizeMethodTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CropAndResizeMethodTypeTable
  };
  static const char * const names[] = {
    "BILINEAR",
    "NEAREST"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryOpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "opType",
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PackParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "dataType",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Index",
    "T",
    "beginMask",
    "endMask",
    "ellipsisMask",
    "newAxisMask",
    "shrinkAxisMask"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqueezeParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "squeezeDims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CastParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "srcT",
    "dstT"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ReductionTypeTypeTable,
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "operation",
    "dim",
    "coeff",
    "keepDims",
    "dType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Tindices",
    "Tparams",
    "validateIndices",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "Tdim",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SeluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "scale",
    "alpha"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AsStringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "precision",
    "scientific",
    "shortest",
    "width",
    "fillString"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceJoinTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "keepDims",
    "separator"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnaryOpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UnaryOpOperationTypeTable,
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "opType",
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopKV2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "sorted"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropAndResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    CropAndResizeMethodTypeTable
  };
  static const char * const names[] = {
    "extrapolationValue",
    "method"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FillTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherV2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Taxis",
    "Tindices",
    "Tparams"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionV2TypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RangeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Tidx"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RankTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "outputDataType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransposeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "Tperm"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceTfTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantizeMaxMinTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "axis",
    "offset"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceBatchTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "blockShape",
    "padding"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatMulTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "T",
    "transposeA",
    "transposeB",
    "weight",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MomentsParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataTypeTypeTable
  };
  static const char * const names[] = {
    "dim",
    "keepDims",
    "dType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RNNParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    BlobTypeTable
  };
  static const char * const names[] = {
    "numUnits",
    "isBidirectionalRNN",
    "keepAllOutputs",
    "fwGateWeight",
    "fwGateBias",
    "fwCandidateWeight",
    "fwCandidateBias",
    "bwGateWeight",
    "bwGateBias",
    "bwCandidateWeight",
    "bwCandidateBias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchMatMulParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "adjX",
    "adjY"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthSpaceParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "blockSize"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_
